import{u as M,b as j,c as y}from"./query-BgC-0ePs.js";import{s as d}from"./index-laD0T8Yw.js";import{a as q,g as B,u as $}from"./useEffectiveOwner-BN9vJCNM.js";import{m as K}from"./massEmails-cdFsY1gu.js";const E={async dailyRefresh(){const t=[];let a=0,e=0,i=0;const{data:o,error:n}=await d.from("automations").select("id, name, owner_id").in("status",["Active","active"]);if(n)return t.push(`Failed to get active automations: ${n.message}`),{automationsProcessed:a,totalAdded:e,totalRemoved:i,errors:t};for(const s of o||[])try{const r=await this.refreshAutomationSchedule(s.id);e+=r.added,i+=r.removed,a++,r.errors.length>0&&t.push(...r.errors.map(l=>`[${s.name}] ${l}`))}catch(r){t.push(`Failed to refresh automation ${s.name}: ${r.message}`)}return{automationsProcessed:a,totalAdded:e,totalRemoved:i,errors:t}},async generateAutomationSchedule(t){var k,O;const a=[];let e=0;const{data:i,error:o}=await d.from("automations").select("*").eq("id",t).single();if(o)throw o;if(!i)throw new Error("Automation not found");const n=i.nodes||[],s=i.filter_config||{groups:[]},r=n.find(f=>f.type==="trigger"),l=((k=r==null?void 0:r.config)==null?void 0:k.time)||"09:00";(O=r==null?void 0:r.config)!=null&&O.timezone;const c=this.extractDateTriggerRules(s);if(c.length===0)return{scheduled:0,errors:["No date-based trigger rules found - automation uses recurring schedule"]};const m=this.removeRelativeDateRules(s);let _;try{if(i.owner_id)_=await K.getRecipients([i.owner_id],m,{limit:1e4});else{const{data:f,error:A}=await d.from("accounts").select("*").or("person_has_opted_out_of_email.is.null,person_has_opted_out_of_email.eq.false").limit(1e4);if(A)throw A;_=(f||[]).filter(g=>{const w=g.person_email||g.email;return w&&w.includes("@")})}}catch(f){return a.push(`Failed to get matching accounts: ${f.message}`),{scheduled:0,errors:a}}if(!_||_.length===0)return{scheduled:0,errors:["No accounts match the base filter criteria"]};const F=_.map(f=>f.account_unique_id),{data:v,error:S}=await d.from("policies").select("account_id, policy_lob, expiration_date, effective_date, policy_status").in("account_id",F).eq("policy_status","Active");if(S)return a.push(`Failed to get policies: ${S.message}`),{scheduled:0,errors:a};const u=this.calculateTriggerDates(_,v||[],c,i),h=this.buildEmailSchedule(n),N=[...new Set(h.map(f=>f.templateId))],{data:z}=await d.from("email_templates").select("id, from_email, from_name, subject").in("id",N),C={};(z||[]).forEach(f=>{C[f.id]=f});const{data:V}=await d.from("scheduled_emails").select("account_id, template_id, qualification_value").eq("automation_id",t).in("status",["Pending","Processing"]),T=new Set((V||[]).map(f=>`${f.account_id}:${f.template_id}:${f.qualification_value}`)),b=[],R=new Date;R.setHours(0,0,0,0);for(const f of _){const A=u[f.account_unique_id]||[];for(const g of A)for(const w of h){const D=new Date(g.date);D.setDate(D.getDate()+w.daysOffset);const[L,W]=l.split(":").map(Number);if(D.setHours(L,W,0,0),D<R)continue;const P=g.date.toISOString().split("T")[0],Q=`${f.account_unique_id}:${w.templateId}:${P}`;if(T.has(Q))continue;const x=C[w.templateId]||{};b.push({owner_id:f.owner_id,automation_id:t,account_id:f.account_unique_id,template_id:w.templateId,recipient_email:f.person_email||f.email,recipient_name:f.primary_contact_first_name?`${f.primary_contact_first_name} ${f.primary_contact_last_name||""}`.trim():f.name,scheduled_for:D.toISOString(),status:"Pending",qualification_value:P,trigger_field:g.field,node_id:w.nodeId,requires_verification:!0,from_email:x.from_email,from_name:x.from_name,subject:x.subject}),T.add(Q)}}const I=100;for(let f=0;f<b.length;f+=I){const A=b.slice(f,f+I),{error:g}=await d.from("scheduled_emails").insert(A);g?a.push(`Batch insert error: ${g.message}`):e+=A.length}return{scheduled:e,errors:a}},extractDateTriggerRules(t){var i,o;const a=[],e=(t==null?void 0:t.groups)||[];for(const n of e)for(const s of n.rules||[])["policy_expiration","policy_effective","account_created"].includes(s.field)&&["in_next_days","in_last_days","less_than_days_future","more_than_days_future"].includes(s.operator)&&a.push({field:s.field,operator:s.operator,value:parseInt(s.value,10),policyType:(o=(i=n.rules)==null?void 0:i.find(r=>r.field==="active_policy_type"||r.field==="policy_type"))==null?void 0:o.value});return a},removeRelativeDateRules(t){const a={...t};return a.groups=(t.groups||[]).map(e=>({...e,rules:(e.rules||[]).filter(i=>["policy_expiration","policy_effective","account_created"].includes(i.field)?!["in_next_days","in_last_days","less_than_days_future","more_than_days_future"].includes(i.operator):!0)})),a},calculateTriggerDates(t,a,e,i){const o={},n={};for(const s of a)n[s.account_id]||(n[s.account_id]=[]),n[s.account_id].push(s);for(const s of t){o[s.account_unique_id]=[];const r=n[s.account_unique_id]||[];for(const l of e)if(l.field==="policy_expiration"||l.field==="policy_effective"){const c=l.field==="policy_expiration"?"expiration_date":"effective_date";for(const m of r){if(l.policyType&&!l.policyType.split(",").map(v=>v.toLowerCase().trim()).some(v=>{var S;return(S=m.policy_lob)==null?void 0:S.toLowerCase().includes(v)}))continue;const _=m[c];_&&o[s.account_unique_id].push({field:l.field,date:new Date(_),policyLob:m.policy_lob})}}else l.field==="account_created"&&s.created_at&&o[s.account_unique_id].push({field:l.field,date:new Date(s.created_at)})}return o},buildEmailSchedule(t){const a=[];let e=0;const i=n=>{var s,r,l;for(const c of n){if(c.type==="send_email"&&((s=c.config)!=null&&s.template))a.push({nodeId:c.id,templateId:c.config.template,daysOffset:e});else if(c.type==="delay"){const m=((r=c.config)==null?void 0:r.duration)||0,_=((l=c.config)==null?void 0:l.unit)||"days";_==="days"?e+=m:_==="weeks"?e+=m*7:_==="hours"&&(e+=m/24)}c.branches&&c.branches.yes&&i(c.branches.yes)}},o=t.filter(n=>n.type!=="entry_criteria"&&n.type!=="trigger");return i(o),a},async verifyAccountQualifies(t){const{automation_id:a,account_id:e,qualification_value:i,trigger_field:o}=t,{data:n,error:s}=await d.from("automations").select("*").eq("id",a).single();if(s||!n)return{qualifies:!1,reason:"Automation not found or inactive"};if(n.status!=="Active"&&n.status!=="active")return{qualifies:!1,reason:"Automation is not active"};const{data:r,error:l}=await d.from("accounts").select("*").eq("account_unique_id",e).single();if(l||!r)return{qualifies:!1,reason:"Account not found"};if(r.person_has_opted_out_of_email)return{qualifies:!1,reason:"Account has opted out of email"};if(o==="policy_expiration"||o==="policy_effective"){const c=o==="policy_expiration"?"expiration_date":"effective_date",{data:m}=await d.from("policies").select("*").eq("account_id",e).eq("policy_status","Active").eq(c,i);if(!m||m.length===0)return{qualifies:!1,reason:`Policy with ${o} = ${i} no longer exists or is inactive`}}if(t.template_id){const c=new Date;c.setDate(c.getDate()-7);const{data:m}=await d.from("email_logs").select("id").eq("template_id",t.template_id).ilike("to_email",(r.person_email||r.email||"").trim()).gte("sent_at",c.toISOString()).in("status",["Sent","Delivered","Opened","Clicked"]).limit(1);if(m&&m.length>0)return{qualifies:!1,reason:"Template already sent to this recipient within 7 days"}}return{qualifies:!0}},async getEmailsForVerification(){const t=new Date,a=new Date(t.getTime()+24*60*60*1e3),{data:e,error:i}=await d.from("scheduled_emails").select("*").eq("status","Pending").eq("requires_verification",!0).lte("scheduled_for",a.toISOString()).gte("scheduled_for",t.toISOString()).order("scheduled_for");if(i)throw i;return e||[]},async runVerification(){const t=[];let a=0,e=0;const i=await this.getEmailsForVerification();for(const o of i)try{const n=await this.verifyAccountQualifies(o);n.qualifies?(await d.from("scheduled_emails").update({requires_verification:!1}).eq("id",o.id),a++):(await d.from("scheduled_emails").update({status:"Cancelled",error_message:n.reason}).eq("id",o.id),e++)}catch(n){t.push(`Error verifying email ${o.id}: ${n.message}`)}return{verified:a,cancelled:e,errors:t}},async cleanupAutomationSchedule(t){const{data:a,error:e}=await d.from("scheduled_emails").update({status:"Cancelled",error_message:"Automation deactivated"}).eq("automation_id",t).eq("status","Pending").select("id");if(e)throw e;return{cancelled:(a==null?void 0:a.length)||0}},async refreshAutomationSchedule(t){const a=[];let e=0,i=0;const{data:o}=await d.from("scheduled_emails").select("*").eq("automation_id",t).eq("status","Pending");for(const s of o||[])try{const r=await this.verifyAccountQualifies(s);r.qualifies||(await d.from("scheduled_emails").update({status:"Cancelled",error_message:r.reason}).eq("id",s.id),i++)}catch(r){a.push(`Error checking email ${s.id}: ${r.message}`)}const n=await this.generateAutomationSchedule(t);return e=n.scheduled,a.push(...n.errors),{added:e,removed:i,errors:a}},async handleStatusChange(t,a){return a==="active"||a==="Active"?this.generateAutomationSchedule(t):this.cleanupAutomationSchedule(t)},async handleNewAccount(t,a){const{data:e}=await d.from("automations").select("*").eq("owner_id",a).in("status",["Active","active"]);if(!e||e.length===0)return{scheduled:0};let i=0;for(const o of e){const n=o.filter_config;if(!n)continue;const{data:s}=await d.from("accounts").select("*").eq("account_unique_id",t).single();if(!s)continue;if((await K.getRecipients([a],n,{limit:1})).some(c=>c.account_unique_id===t)){const c=await this.generateAutomationSchedule(o.id);i+=c.scheduled}}return{scheduled:i}},async handlePolicyChange(t,a){const{data:e}=await d.from("accounts").select("owner_id").eq("account_unique_id",t).single();if(!e)return{updated:0};const{data:i}=await d.from("automations").select("*").eq("owner_id",e.owner_id).in("status",["Active","active"]);if(!i)return{updated:0};let o=0;for(const n of i)this.extractDateTriggerRules(n.filter_config).some(l=>l.field==="policy_expiration"||l.field==="policy_effective")&&(await this.refreshAutomationSchedule(n.id),o++);return{updated:o}}},p={async getAll(t,a={}){const{status:e,category:i,search:o}=a;let n=d.from("automations").select(`
        *,
        _count:automation_enrollments(count)
      `).order("is_default",{ascending:!1}).order("name");n=q(n,t),e&&(n=n.eq("status",e)),i&&(n=n.eq("category",i)),o&&(n=n.or(`name.ilike.%${o}%,description.ilike.%${o}%`));const{data:s,error:r}=await n;if(r)throw r;return s},async getAllWithStats(t){let a=d.from("automations").select("*").order("is_default",{ascending:!1}).order("name");a=q(a,t);const{data:e,error:i}=await a;if(i)throw i;const o=e.map(l=>l.id),{data:n,error:s}=await d.from("automation_enrollments").select("automation_id, status").in("automation_id",o);if(s)throw s;const r={};return n.forEach(l=>{r[l.automation_id]||(r[l.automation_id]={total:0,active:0,completed:0,exited:0}),r[l.automation_id].total++,r[l.automation_id][l.status.toLowerCase()]++}),e.map(l=>({...l,enrollmentStats:r[l.id]||{total:0,active:0,completed:0,exited:0}}))},async getById(t,a){let e=d.from("automations").select("*").eq("id",a);e=q(e,t);const{data:i,error:o}=await e.single();if(o)throw o;return i},async getByIdWithDetails(t,a){const e=await this.getById(t,a),{data:i,error:o}=await d.from("automation_enrollments").select("status").eq("automation_id",a);if(o)throw o;const n={total:i.length,active:i.filter(c=>c.status==="Active").length,completed:i.filter(c=>c.status==="Completed").length,exited:i.filter(c=>c.status==="Exited").length,paused:i.filter(c=>c.status==="Paused").length},{data:s,error:r}=await d.from("email_logs").select("status, open_count, click_count").eq("automation_id",a);if(r)throw r;const l={sent:s.length,delivered:s.filter(c=>c.status==="Delivered"||c.status==="Opened"||c.status==="Clicked").length,opened:s.filter(c=>c.open_count>0).length,clicked:s.filter(c=>c.click_count>0).length,bounced:s.filter(c=>c.status==="Bounced").length};return{...e,enrollmentStats:n,emailSummary:l}},async getByDefaultKey(t,a){let e=d.from("automations").select("*").eq("default_key",a);e=q(e,t);const{data:i,error:o}=await e.single();if(o)throw o;return i},async create(t,a){const e=B(t),{data:i,error:o}=await d.from("automations").insert({owner_id:e,is_default:!1,status:"Draft",...a}).select().single();if(o)throw o;return i},async update(t,a,e){const i=e.filter_config!==void 0||e.nodes!==void 0||e.send_time!==void 0;let o=d.from("automations").update({...e,updated_at:new Date().toISOString()}).eq("id",a);o=q(o,t);const{data:n,error:s}=await o.select().single();if(s)throw s;if(i&&n&&(n.status==="Active"||n.status==="active"))try{await E.cleanupAutomationSchedule(a),await E.generateAutomationSchedule(a)}catch(r){console.warn("Failed to refresh automation schedule after update:",r.message)}return n},async updateStatus(t,a,e){const i=await this.update(t,a,{status:e});try{await E.handleStatusChange(a,e)}catch(o){console.warn("Failed to handle automation schedule:",o.message)}return i},async activate(t,a){return this.updateStatus(t,a,"active")},async pause(t,a){return this.updateStatus(t,a,"paused")},async archive(t,a){return this.updateStatus(t,a,"archived")},async delete(t,a){let e=d.from("automations").delete().eq("id",a).eq("is_default",!1);e=q(e,t);const{error:i}=await e;if(i)throw i;return!0},async duplicate(t,a){const e=await this.getById(t,a),i=B(t),{data:o,error:n}=await d.from("automations").insert({owner_id:i,is_default:!1,default_key:null,name:`${e.name} (Copy)`,description:e.description,category:e.category,status:"Draft",send_time:e.send_time,timezone:e.timezone,frequency:e.frequency,max_enrollments:e.max_enrollments,enrollment_cooldown_days:e.enrollment_cooldown_days,distribute_evenly:e.distribute_evenly,filter_config:e.filter_config,nodes:e.nodes}).select().single();if(n)throw n;return o},async updateFilters(t,a,e){return this.update(t,a,{filter_config:e})},async updateNodes(t,a,e){return this.update(t,a,{nodes:e})},async updateSchedule(t,a,e){const{sendTime:i,timezone:o,frequency:n}=e;return this.update(t,a,{send_time:i,timezone:o,frequency:n})},async updateEnrollmentRules(t,a,e){const{maxEnrollments:i,cooldownDays:o,distributeEvenly:n}=e;return this.update(t,a,{max_enrollments:i,enrollment_cooldown_days:o,distribute_evenly:n})},async getByStatus(t,a){let e=d.from("automations").select("*").eq("status",a).order("name");e=q(e,t);const{data:i,error:o}=await e;if(o)throw o;return i},async getActive(t){return this.getByStatus(t,"Active")},async getCategories(t){let a=d.from("automations").select("category").not("category","is",null);a=q(a,t);const{data:e,error:i}=await a;if(i)throw i;return[...new Set(e.map(o=>o.category))]}};function X(){const{ownerIds:t,filterKey:a}=$();return M({queryKey:["automations",a,"withStats"],queryFn:()=>p.getAllWithStats(t),enabled:t.length>0})}function Y(t){const{ownerIds:a,filterKey:e}=$();return M({queryKey:["automation",e,t],queryFn:()=>p.getById(a,t),enabled:a.length>0&&!!t})}function Z(){const{ownerIds:t,filterKey:a}=$(),e=j(),i=()=>{e.invalidateQueries({queryKey:["automations"]})},o=y({mutationFn:u=>p.create(t,u),onSuccess:i}),n=y({mutationFn:({automationId:u,updates:h})=>p.update(t,u,h),onSuccess:u=>{i(),e.setQueryData(["automation",a,u.id],u)}}),s=y({mutationFn:u=>p.delete(t,u),onSuccess:i}),r=y({mutationFn:u=>p.duplicate(t,u),onSuccess:i}),l=y({mutationFn:u=>p.activate(t,u),onSuccess:u=>{i(),e.setQueryData(["automation",a,u.id],u)}}),c=y({mutationFn:u=>p.pause(t,u),onSuccess:u=>{i(),e.setQueryData(["automation",a,u.id],u)}}),m=y({mutationFn:u=>p.archive(t,u),onSuccess:i}),_=y({mutationFn:({automationId:u,filterConfig:h})=>p.updateFilters(t,u,h),onSuccess:u=>{e.setQueryData(["automation",a,u.id],u)}}),F=y({mutationFn:({automationId:u,nodes:h})=>p.updateNodes(t,u,h),onSuccess:u=>{e.setQueryData(["automation",a,u.id],u)}}),v=y({mutationFn:({automationId:u,scheduleConfig:h})=>p.updateSchedule(t,u,h),onSuccess:u=>{e.setQueryData(["automation",a,u.id],u)}}),S=y({mutationFn:({automationId:u,rules:h})=>p.updateEnrollmentRules(t,u,h),onSuccess:u=>{e.setQueryData(["automation",a,u.id],u)}});return{createAutomation:o,updateAutomation:n,deleteAutomation:s,duplicateAutomation:r,activateAutomation:l,pauseAutomation:c,archiveAutomation:m,updateFilters:_,updateNodes:F,updateSchedule:v,updateEnrollmentRules:S}}export{Z as a,Y as b,X as u};
